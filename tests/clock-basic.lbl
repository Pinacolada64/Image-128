{undef:all_ml}
{ifdef:all_ml}
orig $1c01	; 7169

; basic sys line
; 7169-7170 line link:
	word end_of_line
; 7171-7172 line number:
	word 10
; 7173      'sys' token:
	byte $9e
; 7174-7177 address:
	ascii "7181"

end_of_line:
; 7178      zero byte
	byte $00
; 7179-7180 end of program:
	word $0000
{else}
{loadaddr:$1c01}
	10 input"hour,minute";h,m:sys{sym:start},0,h,m
{endif}
{asm}
colon	= 58

	; cia time-of-day clock registers:
tod_tenths	= $dc08	; tenths of a second
tod_secs	= $dc09	; seconds
tod_min		= $dc0a	; minutes
tod_hrs		= $dc0b	; hours
cia_crb		= $dc0f	; cia #1 control register b

; memory management unit control register:
mmu_cr		= $ff00

start:
	stx store+1
	sty store+3

; bank 0 in:
	php
	pha
	lda #$00
	sta mmu_cr	; $ff00
	pla
	plp

; set tod clock:
; .x: hour, .y=minute
store:
	ldx #91
	ldy #59
	jsr settim

; display time
clock:
	ldy #$00 	; index

	lda tod_hrs	; tens digit
	pha
	and #$10
	jsr bcd_to_ascii_tens_digit+2
	pla
	jsr bcd_to_ascii_ones_digit

	lda #colon
	jsr clock_display

	lda tod_min	; tens digit
	pha
	jsr bcd_to_ascii_tens_digit
	pla
	jsr bcd_to_ascii_ones_digit

	lda #colon
	jsr clock_display

	lda tod_secs	; tens digit
	pha
	jsr bcd_to_ascii_tens_digit
	pla
	jsr bcd_to_ascii_ones_digit

	lda #' '
	jsr clock_display

	; get am/pm flag:
	bit tod_hrs	; $dc0b
	bne time_pm	; bit 7: 1=pm
	lda #'A'
	byte $2c
time_pm:
	lda #'P'
	jsr clock_display

	lda #'M'
	jsr clock_display

	lda tod_tenths	; read to un-latch clock
	jsr $ffe1
	bne clock
basic:
	rts

bcd_to_ascii_tens_digit:
	and #$f0
	lsr
	lsr
	lsr
	lsr
	jmp clock_display

bcd_to_ascii_ones_digit:
	and #$0f

clock_display:
	jsr petscii_to_screencode
	cmp #'9'
	bcc rvs_nums
	ora #$b0	; %1011 0000
	byte $2c
rvs_nums:
	ora #$80
	sta $0400+(40*24)+18,y
	iny
	rts

petscii_to_screencode:
	; by Mace on CSDB
	; convert ASCII/PetSCII to screen code
	; enter with .a: value

	cmp #$20	; if A<32 then...
	bcc ddRev

	cmp #$60	; if A<96 then...
	bcc dd1

	cmp #$80	; if A<128 then...
	bcc dd2

	cmp #$a0	; if A<160 then...
	bcc dd3

	cmp #$c0	; if A<192 then...
	bcc dd4

	cmp #$ff	; if A<255 then...
	bcc ddRev

	lda #$7e	; A=255, then A=126
	bne ddEnd

dd2:
	and #$5f	; if A=96..127 then strip bits 5 and 7
	bne ddEnd

dd3:
	ora #$40	; if A=128..159, then set bit 6
	bne ddEnd

dd4:
	eor #$c0	; if A=160..191 then flip bits 6 and 7
	bne ddEnd

dd1:
	and #$3f	; if A=32..95 then strip bits 6 and 7
	bpl ddEnd

ddRev:
	eor #$80	; flip bit 7 (reverse on when off and vice versa)
ddEnd:
	; screen code is now in accumulator
	rts

settim:
; enter with:
; .x: hour    (01-12, 81-92=PM)
; .y: minute  (00-59)
	lda #$01
	byte $2c
setalm:
	lda #$81
	sta cia_crb
	cmp #$81
	beq settim2
	lda #1
	sta timeflag
	cpx #12
	bne settim1
	ldx #92
	bne settim2
settim1:
	cpx #92
	bne settim2
	ldx #12
settim2:
	txa
	jsr settim3
	sta tod_hrs
	tya
	jsr settim3
	sta tod_min
	lda #0
	sta tod_secs
	sta tod_tenths
	lda #$01
	sta cia_crb
	rts
settim3:
	ldx #0
settim4:
	cmp #10
	bcc settim5
	sbc #10
	inx
	bne settim4
settim5:
; .a to bcd
	sta $ff
	txa
	asl
	asl
	asl
	asl
	ora $ff
	rts

timeflag:
	byte 0
{ifndef:all_ml}
{endasm}
{endif}
